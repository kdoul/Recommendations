package gr.unipi.msc.bigdata.recommender;

import java.io.*;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Arrays;
import java.util.Random;
import java.util.StringTokenizer;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class App {
//    public String getGreeting() {
//        return "Hello world.";
//    }
//
//    public static void main(String[] args) {
//        System.out.println(new App().getGreeting());
//    }

    public static double[][] CreateMatrix(String inputFile) throws FileNotFoundException, IOException {
        // Initialize the matrix with -1 for all elements
        double[][] matrix = new double[1000][2069];
        for (int i = 0; i < matrix.length; ++i) {
            for (int j = 0; j < matrix[0].length; ++j) {
                matrix[i][j] = -1f;
            }
        }

        // Read the input values and form the full matrix
        BufferedReader br = new BufferedReader(new FileReader(inputFile));
        StringTokenizer st = null;
        String row;
        while ((row = br.readLine()) != null) {
            st = new StringTokenizer(row, ",");
            while (st.hasMoreTokens()) {
                int user = Integer.parseInt(st.nextToken());
                int movie = Integer.parseInt(st.nextToken());
                double rating = Integer.parseInt(st.nextToken());
                matrix[user - 1][movie - 1] = rating;
                st.nextToken();
            }
        }
        return matrix;
    }

    public static int[][] testData(String testFile) throws FileNotFoundException, IOException {
        BufferedReader br = new BufferedReader(new FileReader(testFile));
        StringTokenizer st = null;
        String row;
        int[][] data = new int[17636][2];
        int i = 0;
        while ((row = br.readLine()) != null) {
            st = new StringTokenizer(row, ",");
            while (st.hasMoreTokens()) {
                data[i][0] = Integer.parseInt(st.nextToken());
                data[i][1] = Integer.parseInt(st.nextToken());
            }
            i += 1;
        }
        return data;
    }

    public static Pair<double[][], double[][]> myRecommender(double[][] matrix, int r, double rate, double lambda)
    {
        int maxIter = 100;
        int n1 = matrix.length;
        int n2 = matrix[0].length;

        double[][] U = new double[n1][r];
        double[][] V = new double[n2][r];

        // Initialize U and V matrix
        Random rand = new Random();
        for (int i = 0; i < U.length; ++i)
        {
            for (int j = 0; j < U[0].length; ++j)
            {
                U[i][j] = rand.nextDouble()/(double)r;
            }
        }

        for (int i = 0; i < V.length; ++i)
        {
            for (int j = 0; j < V[0].length; ++j)
            {
                V[i][j] = rand.nextDouble()/(double)r;
            }
        }


        // Gradient Descent
        for (int iter = 0; iter < maxIter; ++iter)
        {
//			System.out.println("Iteration no. " + iter + " / " + maxIter);

            double[][] prodMatrix = new double[n1][n2];
            for (int i = 0; i < n1; ++i)
            {
                for (int j = 0; j < n2; ++j)
                {
                    for (int k = 0; k < r; ++k)
                    {
                        prodMatrix[i][j] += U[i][k]*V[j][k];
                    }
                }
            }

            double[][] errorMatrix = new double[n1][n2];
            for (int i = 0; i < n1; ++i)
            {
                for (int j = 0; j < n2; ++j)
                {
                    if (matrix[i][j] == 0f)
                    {
                        errorMatrix[i][j] = 0f;
                    }
                    else
                    {
                        errorMatrix[i][j] = matrix[i][j] - prodMatrix[i][j];
                    }
                }
            }

            double[][] UGrad = new double[n1][r];
            for (int i = 0; i < n1; ++i)
            {
                for (int j = 0; j < r; ++j)
                {
                    for (int k = 0; k < n2; ++k)
                    {
                        UGrad[i][j] += errorMatrix[i][k]*V[k][j];
                    }
                }
            }

            double[][] VGrad = new double[n2][r];
            for (int i = 0; i < n2; ++i)
            {
                for (int j = 0; j < r; ++j)
                {
                    for (int k = 0; k < n1; ++k)
                    {
                        VGrad[i][j] += errorMatrix[k][i]*U[k][j];
                    }
                }
            }

            double[][] Un = new double[n1][r];
            for (int i = 0; i < n1; ++i)
            {
                for (int j = 0; j < r; ++j)
                {
                    Un[i][j] = (1f - rate*lambda)*U[i][j] + rate*UGrad[i][j];
                }
            }

            double[][] Vn = new double[n2][r];
            for (int i = 0; i < n2; ++i)
            {
                for (int j = 0; j < r; ++j)
                {
                    Vn[i][j] = (1f - rate*lambda)*V[i][j] + rate*VGrad[i][j];
                }
            }

            U = Un;
            V = Vn;
        }

        double[][] prodMatrix = new double[n1][n2];
        for (int i = 0; i < n1; ++i) {
            for (int j = 0; j < n2; ++j) {
                for (int k = 0; k < 2; ++k) {
                    prodMatrix[i][j] += U[i][k] * V[j][k];
                }
            }
        }

        System.out.println("Unbiased Matrix:");
        for (double[] row : prodMatrix) {
            System.out.println(Arrays.toString(row));
        }
        System.out.println("Mean square error: "+ getMSE(matrix,prodMatrix).toPlainString());

        Pair<double[][], double[][]> p = new Pair<double[][], double[][]>(U,V);
        return p;
    }


    public static Pair<double[][], double[][]> myBiasedRecommender(double[][] matrix, int r, double rate, double lambda)
    {
        int maxIter = 100;
        int n1 = matrix.length;
        int n2 = matrix[0].length;

        double[][] U = new double[n1][r];
        double[][] V = new double[n2][r];

        double[] userBias = new double[n1];
        double[] itemBias = new double[n2];

        // Initialize U and V matrix
        Random rand = new Random();
        for (int i = 0; i < U.length; ++i)
        {
            for (int j = 0; j < U[0].length; ++j)
            {
                U[i][j] = rand.nextDouble()/(double)r;
            }
        }

        for (int i = 0; i < V.length; ++i)
        {
            for (int j = 0; j < V[0].length; ++j)
            {
                V[i][j] = rand.nextDouble()/(double)r;
            }
        }

        double globalBias = getMeanRating(matrix);


        // Gradient Descent
        for (int iter = 0; iter < maxIter; ++iter)
        {
//			System.out.println("Iteration no. " + iter + " / " + maxIter);

            double[][] prodMatrix = new double[n1][n2];
            for (int i = 0; i < n1; ++i)
            {
                for (int j = 0; j < n2; ++j)
                {
                    for (int k = 0; k < r; ++k)
                    {
                        prodMatrix[i][j] += U[i][k]*V[j][k];
                    }
                }
            }

            for (int i = 0; i < n1; ++i) {
                for (int j = 0; j < n2; ++j) {
                    if (matrix[i][j] != 0)
                        prodMatrix[i][j] += userBias[i] + itemBias[j] + globalBias;
                }
            }

            double[][] errorMatrix = new double[n1][n2];
            for (int i = 0; i < n1; ++i)
            {
                for (int j = 0; j < n2; ++j)
                {
                    if (matrix[i][j] == 0f)
                    {
                        errorMatrix[i][j] = 0f;
                    }
                    else
                    {
                        errorMatrix[i][j] = matrix[i][j] - prodMatrix[i][j];
                        userBias[i] += rate * (errorMatrix[i][j] - lambda * userBias[i]);
                        itemBias[j] += rate * (errorMatrix[i][j] - lambda * userBias[j]);
                    }
                }
            }
//            System.out.println("User bias matrix:");
//            System.out.println(Arrays.toString(userBias));
//            System.out.println("Item bias matrix:");
//            System.out.println(Arrays.toString(itemBias));

            double[][] UGrad = new double[n1][r];
            for (int i = 0; i < n1; ++i)
            {
                for (int j = 0; j < r; ++j)
                {
                    for (int k = 0; k < n2; ++k)
                    {
                        UGrad[i][j] += errorMatrix[i][k]*V[k][j];
                    }
                }
            }

            double[][] VGrad = new double[n2][r];
            for (int i = 0; i < n2; ++i)
            {
                for (int j = 0; j < r; ++j)
                {
                    for (int k = 0; k < n1; ++k)
                    {
                        VGrad[i][j] += errorMatrix[k][i]*U[k][j];
                    }
                }
            }

            double[][] Un = new double[n1][r];
            for (int i = 0; i < n1; ++i)
            {
                for (int j = 0; j < r; ++j)
                {
                    Un[i][j] = (1f - rate*lambda)*U[i][j] + rate*UGrad[i][j];
                }
            }

            double[][] Vn = new double[n2][r];
            for (int i = 0; i < n2; ++i)
            {
                for (int j = 0; j < r; ++j)
                {
                    Vn[i][j] = (1f - rate*lambda)*V[i][j] + rate*VGrad[i][j];
                }
            }

            U = Un;
            V = Vn;
        }

        double[][] prodMatrix = new double[n1][n2];
        for (int i = 0; i < n1; ++i) {
            for (int j = 0; j < n2; ++j) {
                for (int k = 0; k < 2; ++k) {
                    prodMatrix[i][j] += U[i][k] * V[j][k];
                }
            }
        }

        for (int i = 0; i < n1; ++i) {
            for (int j = 0; j < n2; ++j) {
                    prodMatrix[i][j] += userBias[i] + itemBias[j] + globalBias;
            }
        }

        System.out.println("Biased matrix:");
        for (double[] row : prodMatrix) {
            System.out.println(Arrays.toString(row));
        }
        System.out.println("Mean square error: "+ getMSE(matrix,prodMatrix).toPlainString());


        Pair<double[][], double[][]> p = new Pair<double[][], double[][]>(U,V);
        return p;
    }


    public static void PredictRating(double[][] U, double[][] V, int[][] test) throws FileNotFoundException, IOException {
        int n1 = U.length;
        int n2 = V.length;
        int r = V[0].length;

        double[][] prodMatrix = new double[n1][n2];
        for (int i = 0; i < n1; ++i) {
            for (int j = 0; j < n2; ++j) {
                for (int k = 0; k < r; ++k) {
                    prodMatrix[i][j] += U[i][k] * V[j][k];
                }
            }
        }

        PrintWriter writer = new PrintWriter("result.csv", "UTF-8");
        for (int i = 0; i < test.length; ++i) {
            int user = test[i][0] - 1;
            int movie = test[i][1] - 1;
            writer.println(prodMatrix[user][movie]);
        }
        writer.close();
    }

    public static void main(String args[]) throws IOException {
        System.out.println("Recommendation System Ratings!!!");

        String inputFile = args[0];
        String testFile = args[1];
        String input = args[2];
        int r = Integer.parseInt(input);
        input = args[3];
        double rate = Double.parseDouble(input);
        input = args[4];
        double lambda = Double.parseDouble(input);

        double[][] matrix = CreateMatrix(inputFile);
        int[][] test = testData(testFile);

        Pair<double[][], double[][]> p = myRecommender(matrix, r, rate, lambda);
        PredictRating(p.a, p.b, test);
    }

    public static class Pair<A, B> {
        public final A a;
        public final B b;

        public Pair(A a, B b) {
            this.a = a;
            this.b = b;
        }
    }

    private static double getMeanRating(double[][] R) {
        int counter = 0;
        double total = 0f;

        for (int i = 0; i < R.length; ++i) {
            for (int j = 0; j < R[0].length; ++j) {
                if (R[i][j] > 0) {
                    total += R[i][j];
                    counter++;
                }
            }
        }

        return total / (double) counter;
    }

    private static BigDecimal getMSE(double[][] matrix, double[][] prodMatrix){

        BigDecimal error = new BigDecimal(0);

        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if (matrix[i][j] != 0){
                    BigDecimal matrixVal = new BigDecimal(matrix[i][j]);
                    BigDecimal predVal = new BigDecimal(prodMatrix[i][j]);
//                            .setScale(8, RoundingMode.HALF_UP)
//                            .doubleValue();
//
//                    System.out.println("Matrix value is: "+matrixVal);
//                    System.out.println("Predicted value is: "+predVal);
                    BigDecimal errorVal = matrixVal.subtract(predVal).pow(2);
//                            .setScale(8, RoundingMode.HALF_UP)
//                            .doubleValue();

//                    System.out.println("The error is: "+errorVal);

                    error = error.add(errorVal);
                }
//                System.out.println(new BigDecimal(4-4.00068).setScale(8, RoundingMode.HALF_UP));
            }
        }
        return error.setScale(10, RoundingMode.HALF_UP);
    }
}


